- config passing:
    - pass whole config objects and let the managers pull out the config vs
    - pass specific subsets of config and whole config objects vs
    - just pass the specific subset of the config

- entity drawing
    - every entity draws themselves
    - the map tells entities to draw themselves
    - entities update their respective tiles and tell the map to draw all the tiles
    - some other kind of manager draws both
    - as of october 4th 2017, going with:
        - mapmanager is no longer going to really be a thing
          - well, it should be for clamping objects etc, and multiple maps
        - rendermanager is going to draw a list of things that are registered with it
        - entitymanager is going to issue updates to all entities and update their representations that are registered with the rendermanager
        - entitymanager can get you the player entity and will call the player's update function, and maybe .. player manager won't even be a thing now
        - a spec manager..? nah not yet
        - so, steps:
            - snapshot what I've got into a commit
            - move spec loading into entity manager
            - make a render manager
            - move drawing from map manager into render manager
            - make entity manager register entities with render manager
            - make entity manager issue updates to renderer


- context passing
    - immediate execution + convoluted manager passage vs
        - e.g. using an init method
    - non-immediate execution + direct manager passage vs
    - .. some wonderful third option?

a note I'd left in the code while doing those steps above:

/*
 * okay so here's where you're at:
 *
 * the entity manager is most useful right now for calling update
 * on every entity, or perhaps on every member of specific classes
 * of entities.
 *
 * It isn't .. actually doing that yet! Because you have no updating
 * entities. Right now the RenderManager is manually walking the
 * map-layer structure to get information about everything in there,
 * and drawing them directly, and then saying "hey entities, do your
 * updates", and the entity list is just empty.
 *
 * Ideally, the entities can be stored in an easy-to-specify format,
 * which can then be loaded into a common data store for the app,
 * which the entity manager will write to when it calls update,
 * and the render manager will read from when it calls draw.
 *
 * This makes me think that a "mark as dirty" and "get draw list"
 * and stuff might be plausible. The render manager can just ask
 * the entity manager for the list of drawables and call draw on
 * them passing the context they should draw on, while they know
 * how to draw themselves and the manager knows how to compose the
 * list of things-to-draw.
 *
 * The render manager can also ask the entity manager to issue updates
 * to whatever needs updates, and it can sort its own priorities out
 * internally e.g. always update the player, only update the monsters
 * or menus that need updating right now, etc. Mayyyyybe it would scope
 * that down to the "active map". Hm.
 *
 * Food for thought! When you come back, look at having the entity manager
 * hold the common truth and present a draw-list and update-list or something.
 *
 * After that, look at finding ways to make that list more sensible?
 * Or simplifications?
 *  - mapmanager should grab the maps from the config
 *  - everyone should set their current map from the map manager
 *      maps.current_map_id
 *      maps.current_map
 *  - if we need to change a map, the map manager will change it and everyone will update what they are showing
 *  - 
 * Or figure out what's up with the framerate/delta stuff, as the timing just seems off -- DONE, trick was to multiply delta by the # of frames/second
 * Or try building a little map and specifying some entities.
 *   -- SORT OF DONE, I specified movement for a coin to test entity updates
 * Or implement collision detection
 * Or implement non-entity-specific physics
 * Or implement URL-based loading of stuff
 */
