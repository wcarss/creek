-> for the draw list, two options:
1  - array of entities created at map-load
a    - insert player at layer-relevant position into list
b    - new entities are added by specifying a layer or position in draw-list
c      - or they are always added above/below player and we just live with it
d      - or they are added to "the map" and the map is recalculated
e    - entities removed are marked as deactivated/removed from to-draw list
f    - changes are persisted to map either:
g      - never
h      - at the code's discretion
i      - when any entity is added/removed
j      - when maps are changed
k    - the entire map is always drawn
2  - hash of entities created at map-load
a    - every time an entity moves or is moved over/under it is marked dirty
b      - or added to a dirty list sorted or paritioned by layer
c    - render manager draws and clears the dirty list each frame
d    - the dirty list can be bounded to only what the camera sees
e    - new entities are just written into the hash (possibly at a layer)
f    - entities removed are marked as deactivated / removed from to-draw list
g    - changes are persisted to map either:
h      - never
i      - at the code's discretion
j      - when any entity is added/removed
k      - when maps are changed

The code is presently mostly on the side of 1, with statements a,e,g,k being true, and d,h likely shortly to become true (d being the solution in this paradigm to dynamic entities -- just do all the bookkeeping required to insert entities into the draw list where they need to be)

2 has some really big down-the-road advantages, namely c,d,e. The g subtree is the same for each option. Moving over to 2 is a lot of work and could present new challenges that I haven't though of yet, but it feels like it'd be a "better solution".

One open question with 2.d is how the camera-bounding would work -- if the hash is keyed by object id (this is what makes 2.e so nice, entity writing/retrieval is just as easy as having the entity's name and is O(1)), then trying to gather "all the objects within these x and y bounds" will mean iterating over all of the objects, and doing so each frame. If the hash is keyed by x or y or "x,y" or something similar, it's going to make the lookups side of 2.e very hard, and it still doesn't really solve the bounding problem nicely. A third option here is to do multiple hashes: one by object id, one by spatial reference. I think I could somewhat easily implement something quadtree-like to do the lookups quickly. I haven't looked up how to implement a quadtree! But I imagine something like this would be going down: (collapsing to just a 2-tree for convenience of diagramming)

r = map
a = top half of map
b = bottom half of map
c = top half of top half of map
d = bottom half of top half of map
etc...

knowing the size of the leaves and the size of the camera, we can then find the player's location among the leaves and grab the correct number of siblings around the player to limit the drawn world to just the camera's view.

           _g
             \_c
           _h/  \
                 \_a
           _i    /  \
 _           \_d/    \
/          _j/        \
|                      \_r
|          _k          /
|            \_e      /
player ->  _l/  \    /
|                \_b/
|          _m    /
|            \_f/
|          _n/
\_ <- camera draws player + 2 nearest leaves ("leaves of interest") if e.g. one leaf has 10 pixels and we want 20 pixels either direction around the player.

Objects could be stored in this tree and *also* in an object-name hash, and possibly in some others, e.g. "land", "monsters", "physics entities", "projectiles", for easy reference and updating.

This would be cool. And more "right". This would also be _way more_ work than just calculating where to insert things into the draw list.

My chief concern is: I'm not sure how to implement camera-bounding reasonably *without* doing this kind of thing, but this kind of thing sounds like an insane level of work. There's got to be a simpler way.

What would be involved in this?

quadtree {
  height: float,
  width: float,
  x: float,
  y: float,
  entities: "x,y"-keyed hash (or null if not leaf)
  top_right: quadtree (or null if leaf)
  top_left: quadtree (or null if leaf)
  bottom_right: quadtree (or null if leaf)
  bottom_left: quadtree (or null if leaf)
}

-> next day: over the following few hours I wrote a quadtree implementation with range query support. I'm going to integrate it and move over to a mark-as-dirty system, following an algorithm roughly like this:

on update:
  - remove from quadtree
  - mark as dirty
  - update last_x_position and last_y_position (tracking these is new)
  - update x_position and y_position
  - re-add to quadtree

on draw:
  - get entities from quadtree bounded by camera range
  - add every dirty entity to a to-draw list
  -

hmmmmmmmmmmmmmm

I think I need to do a collision detection on the old x,y and the new x,y for every updated entity, and mark *those* as dirty, then draw them all in layer-order. But one of those could have been, say, behind something else, which the updated entity didn't collide with, and when I redraw the background it'll occlude the non-colliding other thing.

I could just draw everything on-screen and damn the mark-as-dirty for now.

¯\_(o-o)_/¯

I can get "everything on-screen" easily enough now that I have the quadtree, and keeping both the quadtree and the by-id hash isn't insane. That clears the path to dynamic entities nicely.
